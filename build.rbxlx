<roblox version="4">
  <Item class="HttpService" referent="0">
    <Properties>
      <string name="Name">HttpService</string>
      <bool name="HttpEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="Lighting" referent="1">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <bool name="Outlines">false</bool>
      <float name="Brightness">2</float>
      <token name="Technology">1</token>
      <bool name="GlobalShadows">true</bool>
    </Properties>
  </Item>
  <Item class="ServerScriptService" referent="2">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="3">
      <Properties>
        <string name="Name">Source</string>
      </Properties>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">Sentry</string>
          <string name="Source">local Hub = require(script.Hub)
local Client = require(script.Client)
local Level = require(script.Level)

local Sentry = {
	Level = Level
}

function Sentry.init(options)
	Sentry._options = options
	Client.init(options)
	Hub.bindClient(Client)
end

function Sentry.captureEvent(event)
	return Hub.captureEvent(event)
end

function Sentry.captureException(error)
	return Hub.captureException(error)
end

function Sentry.captureMessage(message, level)
	return Hub.captureMessage(message, level)
end

function Sentry.addBreadcrumb(crumb)

end

function Sentry.configureScope(callback)

end

return Sentry</string>
        </Properties>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">API</string>
            <string name="Source">local Dsn = require(script.Parent.Dsn)

local SENTRY_API_VERSION = "7"

local API = {}
API.__index = API

function API.new()
	local self = {}
	self._dsnObject = Dsn
	setmetatable(self, API)
	return self
end

function API:getDsn()
	return self._dsnObject
end

function API:getStoreEndpoint()
	return ("%s%s"):format(self:_getBaseUrl(), self:getStoreEndpointPath())
end

function API:_getBaseUrl()
	local dsn = self._dsnObject
	local protocol = dsn.protocol and dsn.protocol..":" or ""
	local port = dsn.port and dsn.port ~= "" and ":"..dsn.port or ""
	return ("%s//%s%s"):format(protocol, dsn.host, port)
end

function API:getStoreEndpointPath()
	local dsn = self._dsnObject
	return ("%s/api/%s/store/"):format(dsn.path and "/"..dsn.path or "", dsn.projectId)
end

function API:getRequestHeaders(clientName, clientVersion)
	local dsn = self._dsnObject
	print(dsn.publicKey)
	local header = {("Sentry sentry_version=%s"):format(SENTRY_API_VERSION),
		("sentry_timestamp=%s"):format(tostring(os.time())),
		("sentry_client=%s/%s"):format(tostring(clientName), tostring(clientVersion)),
		("sentry_key=%s"):format(dsn.publicKey),
		dsn.pass and ("sentry_secret=%s"):format(dsn.secretKey)
	}
	return {
		["Content-Type"] = "application/json",
		["X-Sentry-Auth"] = table.concat(header, ", ")
	}
end

return API</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="6">
          <Properties>
            <string name="Name">Backend</string>
            <string name="Source">local Backend = {}
Backend.__index = Backend

function Backend.new(options)
	local self = {}
	self._options = options
	if not options.dsn then
		warn("No DSN provided, backend will not do anything")
	end
	self._transport = Backend._setupTransport(self)
end

function Backend:eventFromMessage(message, level, hint)
	local event = {
		event_id = hint and hint.event_id,
		level = level,
		message = message
	}

	if self._options.attachStacktrace and hint and hint.syntheticException then

	end
	return event
end

return Backend</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="7">
          <Properties>
            <string name="Name">Client</string>
            <string name="Source">local generateUUID = require(script.Parent.generateUUID)
local Dsn = require(script.Parent.Dsn)
local Version = require(script.Parent.Version)
local Transport = require(script.Parent.Transport)
local Parsers = require(script.Parent.Parsers)
local Cryo = require(script.Parent.Cryo)

local Client = {
	_options = nil,
	_processing = false,
	_dsn = nil
}

function Client.init(options)
	Client._options = options
	Client._transport = Transport.new(options)
	if options.dsn then
		Dsn.fromString(options.dsn)
		Client._dsn = Dsn
	end
	if Client._isEnabled() then
		-- TODO integrations
	end
end

function Client.captureException(exception, hint, scope)
	local eventId = hint and hint.event_id

	Client._processing = true

	local event = {
		event_id = eventId,
		-- message = Parsers.extractMessageFromTrace(exception),
		exception = {
			type = "Error",
			value = Parsers.extractMessageFromTrace(exception),
			stacktrace = {
				frames = Parsers.extractStackFromTrace(exception)
			}
		}
	}

	if Client._options.attachStacktrace and hint and hint.extraTrace then
		local stack = Parsers.extractStackFromTrace(hint.extraTrace)
		event.stacktrace = {
			frames = stack
		}
	end

	if not next(event.exception.stacktrace) then
		event.exception.stacktrace = nil
	end

	local finalEvent = Client._processEvent(event, hint, scope)
	eventId = finalEvent.event_id
	Client._processing = false

	return event
end

function Client.captureMessage(message, level, hint, scope)
	local eventId = hint and hint.event_id

	Client._processing = true

	local event = {
		event_id = hint and hint.event_id,
		level = level,
		message = message
	}

	if Client._options.attachStacktrace and hint and hint.extraTrace then
		local stack = Parsers.extractStackFromTrace(hint.extraTrace)
		event.stacktrace = {
			frames = stack
		}
	end

	local finalEvent = Client._processEvent(event, hint, scope)
	eventId = finalEvent.event_id
	Client._processing = false

	return eventId
end

function Client.captureEvent(event, hint, scope)
	Client._processing = true

	local finalEvent = Client._processEvent(event, hint, scope)
	local eventId = finalEvent.event_id
	Client._processing = false

	return eventId
end

function Client.getDsn()
	return Client._dsn
end

function Client.getOptions()
	return Client._options
end

function Client._isEnabled()
	return Client.getOptions().enabled ~= false and Client.getDsn() ~= nil
end

function Client._processEvent(event, hint, scope)
	if not Client._isEnabled() then
		return
	end
	local prepared = Client._prepareEvent(event, hint, scope)
	local success, result = pcall(function()
		Client._transport:_sendEvent(prepared)
	end)
	if not success then
		warn(result)
	end
	return prepared
end

function Client._prepareEvent(event, hint, scope)
	event.platform = "other"
	event.sdk = Cryo.Dictionary.join(event.sdk or {}, {
		name = Version.SDK_NAME,
		version = Version.SDK_VERSION
	})

	local options = Client.getOptions()
	local environment = options.environment
	local release = options.release
	local dist = options.dist
	local maxValueLength = options.maxValueLength or 250

	local prepared = Cryo.Dictionary.join(event, {})
	if prepared.environment == nil and environment ~= nil then
		prepared.environment = environment
	end
	if prepared.release == nil and release ~= nil then
		prepared.release = release
	end

	if prepared.dist == nil and dist ~= nil then
		prepared.dist = dist
	end

	if prepared.message then
		prepared.message = prepared.message:sub(1, maxValueLength)
	end

	if prepared.event_id == nil then
		prepared.event_id = generateUUID()
	end

	local result = prepared

	if scope then
		result = scope:applyToEvent(prepared, hint)
	end

	return result
end

return Client</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="8">
          <Properties>
            <string name="Name">Cryo</string>
            <string name="Source">return {
	Dictionary = require(script.Dictionary),
	List = require(script.List),
	isEmpty = require(script.isEmpty),
	None = require(script.None),
}</string>
          </Properties>
          <Item class="ModuleScript" referent="9">
            <Properties>
              <string name="Name">Dictionary</string>
              <string name="Source">--[[
	Defines utilities for working with 'dictionary-like' tables.

	Dictionaries can be indexed by any value, but don't have the ordering
	expectations that lists have.
]]

return {
	join = require(script.join),
	keys = require(script.keys),
	values = require(script.values),
}</string>
            </Properties>
            <Item class="ModuleScript" referent="10">
              <Properties>
                <string name="Name">join</string>
                <string name="Source">local None = require(script.Parent.Parent.None)

--[[
	Combine a number of dictionary-like tables into a new table.

	Keys specified in later tables will overwrite keys in previous tables.

	Use `Cryo.None` as a value to remove a key. This is necessary because
	Lua does not distinguish between a value not being present in a table and a
	value being `nil`.
]]
local function join(...)
	local new = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		for key, value in pairs(source) do
			if value == None then
				new[key] = nil
			else
				new[key] = value
			end
		end
	end

	return new
end

return join</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="11">
              <Properties>
                <string name="Name">keys</string>
                <string name="Source">--[[
	Returns a list of the keys from the given dictionary.
]]
local function keys(dictionary)
	local new = {}
	local index = 1

	for key in pairs(dictionary) do
		new[index] = key
		index = index + 1
	end

	return new
end

return keys</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="12">
              <Properties>
                <string name="Name">values</string>
                <string name="Source">--[[
	Returns a list of the values of the given dictionary.
]]

local function values(dictionary)
	local new = {}
	local index = 1

	for _, value in pairs(dictionary) do
		new[index] = value
		index = index + 1
	end

	return new
end

return values</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="13">
            <Properties>
              <string name="Name">List</string>
              <string name="Source">--[[
	Defines utilities for working with 'list-like' tables.
]]

return {
	filter = require(script.filter),
	filterMap = require(script.filterMap),
	find = require(script.find),
	foldLeft = require(script.foldLeft),
	foldRight = require(script.foldRight),
	getRange = require(script.getRange),
	join = require(script.join),
	map = require(script.map),
	removeIndex = require(script.removeIndex),
	removeRange = require(script.removeRange),
	removeValue = require(script.removeValue),
	reverse = require(script.reverse),
	sort = require(script.sort),
}</string>
            </Properties>
            <Item class="ModuleScript" referent="14">
              <Properties>
                <string name="Name">filter</string>
                <string name="Source">--[[
	Create a copy of a list with only values for which `callback` returns true.
	Calls the callback with (value, index).
]]
local function filter(list, callback)
	local new = {}
	local index = 1

	for i = 1, #list do
		local value = list[i]
		if callback(value, i) then
			new[index] = value
			index = index + 1
		end
	end

	return new
end

return filter</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="15">
              <Properties>
                <string name="Name">filterMap</string>
                <string name="Source">--[[
	Create a copy of a list doing a combination filter and map.

	If callback returns nil for any item, it is considered filtered from the
	list. Any other value is considered the result of the 'map' operation.
]]
local function filterMap(list, callback)
	local new = {}
	local index = 1

	for i = 1, #list do
		local result = callback(list[i], i)

		if result ~= nil then
			new[index] = result
			index = index + 1
		end
	end

	return new
end

return filterMap</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="16">
              <Properties>
                <string name="Name">find</string>
                <string name="Source">--[[
	Returns the index of the given value or nil if not found.
]]

local function find(list, value)
	for i = 1, #list do
		if list[i] == value then
			return i
		end
	end
	return nil
end

return find</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="17">
              <Properties>
                <string name="Name">foldLeft</string>
                <string name="Source">--[[
	Performs a left-fold of the list with the given initial value and callback.
]]
local function foldLeft(list, callback, initialValue)
	local accum = initialValue

	for i = 1, #list do
		accum = callback(accum, list[i], i)
	end

	return accum
end

return foldLeft</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="18">
              <Properties>
                <string name="Name">foldRight</string>
                <string name="Source">--[[
	Performs a right-fold of the list with the given initial value and callback.
]]
local function foldRight(list, callback, initialValue)
	local accum = initialValue

	for i = #list, 1, -1 do
		accum = callback(accum, list[i], i)
	end

	return accum
end

return foldRight</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="19">
              <Properties>
                <string name="Name">getRange</string>
                <string name="Source">--[[
	Returns a new list containing only the elements within the given range.
]]

local function getRange(list, startIndex, endIndex)
	assert(startIndex &lt;= endIndex, "startIndex must be less than or equal to endIndex")

	local new = {}
	local index = 1

	for i = math.max(1, startIndex), math.min(#list, endIndex) do
		new[index] = list[i]
		index = index + 1
	end

	return new
end

return getRange</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="20">
              <Properties>
                <string name="Name">join</string>
                <string name="Source">local None = require(script.Parent.Parent.None)

--[[
	Joins any number of lists together into a new list
]]
local function join(...)
	local new = {}

	for listKey = 1, select("#", ...) do
		local list = select(listKey, ...)
		local len = #new

		for itemKey = 1, #list do
			if list[itemKey] == None then
				len = len - 1
			else
				new[len + itemKey] = list[itemKey]
			end
		end
	end

	return new
end

return join</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="21">
              <Properties>
                <string name="Name">map</string>
                <string name="Source">--[[
	Create a copy of a list where each value is transformed by `callback`
]]
local function map(list, callback)
	local new = {}

	for i = 1, #list do
		new[i] = callback(list[i], i)
	end

	return new
end

return map</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="22">
              <Properties>
                <string name="Name">removeIndex</string>
                <string name="Source">--[[
	Remove the element at the given index.
]]
local function removeIndex(list, index)
	local new = {}
	local removed = 0

	for i = 1, #list do
		if i == index then
			removed = 1
		else
			new[i - removed] = list[i]
		end
	end

	return new
end

return removeIndex</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="23">
              <Properties>
                <string name="Name">removeRange</string>
                <string name="Source">--[[
	Remove the range from the list starting from the index.
]]
local function removeRange(list, startIndex, endIndex)
	assert(startIndex &lt;= endIndex, "startIndex must be less than or equal to endIndex")

	local new = {}
	local index = 1

	for i = 1, math.min(#list, startIndex - 1) do
		new[index] = list[i]
		index = index + 1
	end

	for i = endIndex + 1, #list do
		new[index] = list[i]
		index = index + 1
	end

	return new
end

return removeRange</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="24">
              <Properties>
                <string name="Name">removeValue</string>
                <string name="Source">--[[
	Creates a new list that has no occurrences of the given value.
]]
local function removeValue(list, value)
	local new = {}
	local index = 1

	for i = 1, #list do
		if list[i] ~= value then
			new[index] = list[i]
			index = index + 1
		end
	end

	return new
end

return removeValue</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="25">
              <Properties>
                <string name="Name">reverse</string>
                <string name="Source">--[[
	Returns a new list with the reversed order of the given list
]]

local function reverse(list)
	local new = {}
	local len = #list
	local top = len + 1

	for i = 1, len do
		new[i] = list[top - i]
	end

	return new
end

return reverse</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="26">
              <Properties>
                <string name="Name">sort</string>
                <string name="Source">--[[
	Returns a new list, ordered with the given sort callback.
	If no callback is given, the default table.sort will be used.
]]

local function sort(list, callback)
	local new = {}

	for i = 1, #list do
		new[i] = list[i]
	end

	table.sort(new, callback)

	return new
end

return sort</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="27">
            <Properties>
              <string name="Name">None</string>
              <string name="Source">--[[
	Represents a value that is intentionally present, but should be interpreted
	as `nil`.

	Cryo.None is used by included utilities to make removing values more
	ergonomic.
]]

local None = newproxy(true)

getmetatable(None).__tostring = function()
	return "Cryo.None"
end

return None</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="28">
            <Properties>
              <string name="Name">isEmpty</string>
              <string name="Source">local function isEmpty(object)
	return next(object) == nil
end

return isEmpty</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="29">
          <Properties>
            <string name="Name">Dsn</string>
            <string name="Source">local pattern = "^(%w+)%:%/%/(%w+)%:?(%w*)%@([%w%.%-]+)%:?(%d*)%/(%d+)"

local Dsn = {}

function Dsn.fromString(str)
	local protocol, publicKey, secretKey, host, port, projectId = str:match(pattern)
	Dsn.protocol = protocol
	print(protocol)
	Dsn.publicKey = publicKey
	print(publicKey)
	Dsn.secretKey = secretKey or ""
	print(secretKey)
	Dsn.host = host
	print(host)
	Dsn.port = port
	print(port)
	Dsn.projectId = projectId
	print(projectId)
end

return Dsn</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="30">
          <Properties>
            <string name="Name">Error</string>
            <string name="Source">local ErrorType = require(script.Parent.ErrorType)

local Error = {}
Error.__index = Error

function Error.new(message, errorType, trace)
	local self = {}
	self.message = message
	self.errorType = errorType or ErrorType.Error
	self.traceback = trace or debug.traceback(2)
	setmetatable(self, Error)
	return self
end

return Error</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="31">
          <Properties>
            <string name="Name">GlobalEventProcessors</string>
            <string name="Source">local globalEventProcessors = {}

local function getGlobalEventProcessors()
	return globalEventProcessors
end

local function addGlobalEventProcessor(callback)
	globalEventProcessors[#globalEventProcessors + 1] = callback
end

return {
	getGlobalEventProcessors = getGlobalEventProcessors,
	addGlobalEventProcessor = addGlobalEventProcessor
}</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="32">
          <Properties>
            <string name="Name">Hub</string>
            <string name="Source">local generateUUID = require(script.Parent.generateUUID)
local Scope = require(script.Parent.Scope)
local Cryo = require(script.Parent.Cryo)
local Parsers = require(script.Parent.Parsers)

local API_VERSION = 1
local DEFAULT_BREADCRUMBS = 30
local MAX_BREADCRUMBS = 100

local Hub = {
	_client = nil,
	_stack = {Scope.new()},
	_lastEventId = nil
}

function Hub.bindClient(client)
	if Hub._client then
		warn("Can only bind client once")
		return
	end
	Hub._client = client
end

function Hub.getClient()
	return Hub._client
end

function Hub.getStackTop()
	return Hub._stack[#Hub._stack]
end

function Hub.pushScope()
	local stack = Hub._stack
	local parentScope = stack[#stack]
	local scope = Scope.clone(parentScope)
	stack[#stack + 1] = scope
	return scope
end

function Hub.popScope()
	local top = Hub.getStackTop()
	Hub._stack[#Hub._stack] = nil
	return top ~= nil
end

function Hub.withScope(callback)
	local scope = Hub.pushScope()
	pcall(callback, scope)
	Hub.popScope()
end

function Hub.captureException(exceptionString, hint)
	local eventId = generateUUID()
	Hub._lastEventId = eventId

	local hintExtra = {}
	if not Parsers.extractStackFromTrace(exceptionString) then
		-- 1 (here) -> 2 (Static API) -> 3 (original call site)
		local trace = debug.traceback(exceptionString, 3)
		hintExtra = {
			originalException = exceptionString,
			extraTrace = trace
		}
	end

	local finalHint = Cryo.Dictionary.join(hintExtra, hint or {})

	finalHint.event_id = eventId

	Hub.getClient().captureException(exceptionString, finalHint, Hub.getStackTop())

	return eventId
end

function Hub.captureMessage(message, level, hint)
	local eventId = generateUUID()
	Hub._lastEventId = eventId
	local finalHint = hint

	if not hint then
		-- 1 (here) -> 2 (Static API) -> 3 (original call site)
		local trace = debug.traceback(message, 3)
		finalHint = {
			originalException = message,
			extraTrace = trace
		}
	end

	finalHint.event_id = eventId

	Hub.getClient().captureMessage(message, level, finalHint, Hub.getStackTop())

	return eventId
end

function Hub.captureEvent(event, hint)
	local eventId = generateUUID()
	Hub._lastEventId = eventId

	hint = hint or {}
	hint.event_id = eventId

	Hub.getClient().captureEvent(event, hint, Hub.getStackTop())

	return eventId
end

function Hub.lastEventId()
	return Hub._lastEventId
end

return Hub</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="33">
          <Properties>
            <string name="Name">Level</string>
            <string name="Source">local Level = {
	Fatal = "fatal",
	Error = "error",
	Warning = "warning",
	Info = "info",
	Debug = "debug",
}

return Level</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="34">
          <Properties>
            <string name="Name">Parsers</string>
            <string name="Source">local Parsers = {}

function Parsers.extractStackFromTrace(str)
	if not str:match("Stack Begin.-Stack End$") then
		return
	end
	local stack = {}
	for _, line in ipairs(str:split("\n")) do
		local fileName, lineNo, varName = line:match("^Script '(.-)', Line (%d+)%s?%-?%s?(.*)$")
		if not fileName or not lineNo then
			fileName, lineNo, varName = line:match("^(.-), line (%d+)%s?%-?%s?(.*)$")
		end
		if fileName and lineNo then
			local frame = {
				filename = fileName,
				["function"] = varName,
				raw_function = varName,
				lineno = tonumber(lineNo)
			}
			table.insert(stack, 1, frame)
		end
	end
	return stack
end

function Parsers.extractMessageFromTrace(str)
	if not str:match("Stack Begin.-Stack End$") then
		return str
	end
	return str:match("^(.*)Stack Begin.-Stack End$")
end

return Parsers</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="35">
          <Properties>
            <string name="Name">Promise</string>
            <string name="Source">--[[
	An implementation of Promises similar to Promise/A+.
]]

local PROMISE_DEBUG = false

--[[
	Packs a number of arguments into a table and returns its length.
	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	local len = select("#", ...)

	return len, { ... }
end

--[[
	wpcallPacked is a version of xpcall that:
	* Returns the length of the result first
	* Returns the result packed into a table
	* Passes extra arguments through to the passed function; xpcall doesn't
	* Issues a warning if PROMISE_DEBUG is enabled
]]
local function wpcallPacked(f, ...)
	local argsLength, args = pack(...)

	local body = function()
		return f(unpack(args, 1, argsLength))
	end

	local resultLength, result = pack(xpcall(body, debug.traceback))

	-- If promise debugging is on, warn whenever a pcall fails.
	-- This is useful for debugging issues within the Promise implementation
	-- itself.
	if PROMISE_DEBUG and not result[1] then
		warn(result[2])
	end

	return resultLength, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(callback, resolve, reject)
	return function(...)
		local resultLength, result = wpcallPacked(callback, ...)
		local ok = result[1]

		if ok then
			resolve(unpack(result, 2, resultLength))
		else
			reject(unpack(result, 2, resultLength))
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local function createSymbol(name)
	assert(type(name) == "string", "createSymbol requires `name` to be a string.")

	local symbol = newproxy(true)

	getmetatable(symbol).__tostring = function()
		return ("Symbol(%s)"):format(name)
	end

	return symbol
end

local PromiseMarker = createSymbol("PromiseMarker")

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = {
	Started = createSymbol("Started"),
	Resolved = createSymbol("Resolved"),
	Rejected = createSymbol("Rejected"),
}

--[[
	Constructs a new Promise with the given initializing callback.
	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.
	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.
	For example:
		local function get(url)
			return Promise.new(function(resolve, reject)
				spawn(function()
					resolve(HttpService:GetAsync(url))
				end)
			end)
		end
		get("https://google.com")
			:andThen(function(stuff)
				print("Got some stuff!", stuff)
			end)
]]
function Promise.new(callback)
	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		-- A tag to identify us as a promise
		[PromiseMarker] = true,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- If an error occurs with no observers, this will be set.
		_unhandledRejection = false,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
	}

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local _, result = wpcallPacked(callback, resolve, reject)
	local ok = result[1]
	local err = result[2]

	if not ok and self._status == Promise.Status.Started then
		reject(err)
	end

	return self
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(value)
	return Promise.new(function(_, reject)
		reject(value)
	end)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise.all(promises)
	if type(promises) ~= "table" then
		error("Please pass a list of promises to Promise.all", 2)
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i = 1, #promises do
		if not Promise.is(promises[i]) then
			error(("Non-promise value passed into Promise.all at index #%d"):format(i), 2)
		end
	end

	return Promise.new(function(resolve, reject)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			resolvedValues[i] = ...
			resolvedCount = resolvedCount + 1

			if resolvedCount == #promises then
				resolve(resolvedValues)
			end
		end

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			promises[i]:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					reject(...)
				end
			)
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return object[PromiseMarker] == true
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.
	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:andThen(successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise.new(function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	return self:andThen(nil, failureCallback)
end

--[[
	Yield until the promise is completed.
	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:await()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local result
		local resultLength
		local bindable = Instance.new("BindableEvent")

		self:andThen(
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(true)
			end,
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(false)
			end
		)

		local ok = bindable.Event:Wait()
		bindable:Destroy()

		return ok, unpack(result, 1, resultLength)
	elseif self._status == Promise.Status.Resolved then
		return true, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return false, unpack(self._values, 1, self._valuesLength)
	end
end

--[[
	Intended for use in tests.
	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		(...):andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				self:_reject(...)
			end
		)

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		self._unhandledRejection = true
		local err = tostring((...))

		spawn(function()
			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
				err,
				self._source
			)
			warn(message)
		end)
	end
end

return Promise</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="36">
          <Properties>
            <string name="Name">Scope</string>
            <string name="Source">local Cryo = require(script.Parent.Cryo)
local Promise = require(script.Parent.Promise)

local Scope = {}
Scope.__index = Scope

function Scope.new()
	local self = {}

	self._notifyingListeners = false
	self._scopeListeners = {}
	self._eventProcessors = {}
	self._breadcrumbs = {}
	self._user = {}
	self._tags = {}
	self._extra = {}
	self._context = {}
	self._fingerprint = {}
	self._level = nil
	self._transaction = nil
	self._span = nil

	setmetatable(self, Scope)
	return self
end

function Scope.clone(scope)
	local newScope = Scope.new()
	if scope then
		scope._scopeListeners = {}
		newScope._breadcrumbs = Cryo.List.join(scope._breadcrumbs, {})
		newScope._tags = Cryo.Dictionary.join(scope._tags, {})
		newScope._extra = Cryo.Dictionary.join(scope._extra, {})
		newScope._context = Cryo.Dictionary.join(scope._context, {})
		newScope._user = scope._user
		newScope._level = scope._level
		newScope._span = scope._span
		newScope._transaction = scope._transaction
		newScope._fingerprint = scope._fingerprint
		newScope._eventProcessors = Cryo.List.join(scope._eventProcessors, {})
	end
	return newScope
end

function Scope:addScopeListener(callback)
	self._scopeListeners[#self._scopeListeners + 1] = callback
end

function Scope:addEventListener(callback)
	self._eventListeners[#self._eventListeners + 1] = callback
	return self
end

function Scope:_notifyScopeListeners()
	if not self._notifyingListeners then
		self._notifyingListeners = true
		coroutine.wrap(function()
			Cryo.List.forEach(function(callback)
				callback(self)
			end)
			self._notifyingListeners = false
		end)()
	end
end

function Scope:_notifyEventProcessors(processors, event, hint)
	return Promise.new(function(resolve, reject)
		local nextEvent = Cryo.Dictionary.join(event, {})
		for _, processor in ipairs(processors) do
			local success, _nextEvent = pcall(processor, nextEvent, hint)
			if success then
				nextEvent = _nextEvent
			else
				reject(_nextEvent)
			end
		end
		resolve(nextEvent)
	end)
end

function Scope:setUser(user)
	self._user = Cryo.Dictionary.join(user, {})
	self:_notifyScopeListeners()
	return self
end

function Scope:setTags(tags)
	self._tags = Cryo.Dictionary.join(self._tags, tags)
	self:_notifyScopeListeners()
	return self
end

function Scope:setTag(key, value)
	self._tags = Cryo.Dictionary.join(self._tags, {[key] = value})
	self:_notifyScopeListeners()
	return self
end

function Scope:setExtras(extra)
	self._extra = Cryo.Dictionary.join(self._extra, extra)
	self:_notifyScopeListeners()
	return self
end

function Scope:setExtra(key, extra)
	self.extra = Cryo.Dictionary.join(self._extra, {[key] = extra})
	self:_notifyScopeListeners()
	return self
end

function Scope:setFingerprint(fingerprint)
	self._fingerprint = Cryo.Dictionary.join(fingerprint, {})
	self:_notifyScopeListeners()
	return self
end

function Scope:setLevel(level)
	self._level = level
	self:_notifyScopeListeners()
	return self
end

function Scope:setTransaction(transaction)
	self._transaction = transaction
	self:_notifyScopeListeners()
	return self
end

function Scope:setContext(name, context)
	self._context[name] = Cryo.Dictionary.join(context, {})
	self:_notifyScopeListeners()
	return self
end

function Scope:clear()
	self._breadcrumbs = {}
	self._tags = {}
	self._extra = {}
	self._user = {}
	self._context = {}
	self._level = nil
	self._transaction = nil
	self._fingerprint = {}
	self._span = nil
	self:_notifyScopeListeners()
end

function Scope:addBreadcrumb(breadcrumb, maxBreadcrumbs)
	local timestamp = os.time()
	local mergedBreadcrumb = Cryo.Dictionary.join(breadcrumb, {timestamp = timestamp})
	local breadcrumbs = Cryo.List.join(self._breadcrumbs, mergedBreadcrumb)
	if maxBreadcrumbs ~= nil and maxBreadcrumbs >= 0 and #breadcrumbs > maxBreadcrumbs then
		breadcrumbs = Cryo.List.removeRange(breadcrumbs, maxBreadcrumbs, #breadcrumbs)
	end
	self._breadcrumbs = breadcrumbs
	self:_notifyScopeListeners()
	return self
end

function Scope:clearBreadcrumbs()
	self._breadcrumbs = {}
	self:_notifyScopeListeners()
	return self
end

function Scope:applyFingerprint(event)
	if not event.fingerprint then
		event.fingerprint = {}
	else
		if type(event.fingerprint) ~= "table" then
			event.fingerprint = {event.fingerprint}
		end
	end

	if self._fingerprint then
		event.fingerprint = Cryo.List.join(event.fingerprint, self._fingerprint)
	end

	if event.fingerprint and #event.fingerprint == 0 then
		event.fingerprint = nil
	end
end

function Scope:applyToEvent(event, hint)
	if next(self._extra) ~= nil then
		event.extra = Cryo.Dictionary.join(self._extra, event.extra or {})
	end
	if next(self._tags) ~= nil then
		event.tags = Cryo.Dictionary.join(self._tags, event.tags or {})
	end
	if next(self._user) ~= nil then
		event.user = Cryo.Dictionary.join(self._user, event.user or {})
	end
	if next(self._context) ~= nil then
		event.context = Cryo.Dictionary.join(self._context, event.context or {})
	end
	if self._level then
		event.level = self._level
	end
	if self._transaction then
		event.transaction = self._transaction
	end

	self:applyFingerprint(event)

	event.breadcrumbs = Cryo.List.join(event.breadcrumbs or {}, self._breadcrumbs)
	if #event.breadcrumbs == 0 then
		event.breadcrumbs = nil
	end

	return event
end

return Scope</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="37">
          <Properties>
            <string name="Name">TaskQueue</string>
            <string name="Source">local RunService = game:GetService("RunService")

local TaskQueue = {}
TaskQueue.__index = TaskQueue

function TaskQueue.new(maxQueueSize)
	local self = {}
	self._maxQueueSize = maxQueueSize
	self._buffer = {}
	self._thread = coroutine.wrap(function()
		while true do
			while #self._buffer > 0 do
				print'processing'
				local index = #self._buffer
				self._buffer[index]()
				table.remove(self._buffer, index)
			end
			wait(1)
		end
	end)()
	setmetatable(self, TaskQueue)
	return self
end

function TaskQueue:add(callback)
	if #self._buffer &lt; self._maxQueueSize then
		self._buffer[#self._buffer + 1] = callback
		print'added'
	end
end

function TaskQueue:flush(timeout)
	local start = tick()
	while tick() - start &lt;= timeout and self._isRunning do
		RunService.Heartbeat:Wait()
	end
	return self._isRunning == false
end

return TaskQueue</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="38">
          <Properties>
            <string name="Name">Transport</string>
            <string name="Source">local HttpService = game:GetService("HttpService")

local API = require(script.Parent.API)
local Cryo = require(script.Parent.Cryo)
local Version = require(script.Parent.Version)
local TaskQueue = require(script.Parent.TaskQueue)

local Transport = {}
Transport.__index = Transport

function Transport.new(options)
	local self = {}
	self._api = API.new(options.dsn)
	self._options = options
	self._taskQueue = TaskQueue.new(30)
	setmetatable(self, Transport)
	return self
end

function Transport:_getRequestOptions()
	local headers = Cryo.Dictionary.join(
		self._api:getRequestHeaders(Version.SDK_NAME, Version.SDK_VERSION),
		self._options.headers or {}
	)
	local dsn = self._api:getDsn()

	print(self._api:getStoreEndpoint())
	return {
		Url = self._api:getStoreEndpoint(),
		Method = "POST",
		Headers = headers,
	}
end

function Transport:_sendEvent(event)
	self._taskQueue:add(function()
		local request = self:_getRequestOptions()
		local encodeSuccess, encodeResult = pcall(function()
			return HttpService:JSONEncode(event)
		end)
		if not encodeSuccess then
			print(encodeResult)
			return
		end
		request.Body = encodeResult
		local success, response = pcall(function()
			return HttpService:RequestAsync(request)
		end)
		if not success then
			print(response)
			return
		end
		if response.Success then
			print("succeeded")
		else
			if response.Headers and response.Headers["x-sentry-error"] then
				print("error", response.Headers["x-sentry-error"])
			else
				print("error")
			end
		end
	end)
end

function Transport:flush(timeout)
	return self._taskQueue:flush(timeout)
end

return Transport</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="39">
          <Properties>
            <string name="Name">Version</string>
            <string name="Source">return {
	SDK_NAME = "sentry-roblox",
	SDK_VERSION = "1.0"
}</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="40">
          <Properties>
            <string name="Name">generateUUID</string>
            <string name="Source">local HttpService = game:GetService("HttpService")

local function generateUUID()
	return HttpService:GenerateGUID(false):gsub("-", "")
end

return generateUUID</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Script" referent="41">
        <Properties>
          <string name="Name">Test</string>
          <string name="Source">-- local Sentry = require(script.Parent.Sentry)

-- Sentry.init({
-- 	dsn = "",
-- 	attachStacktrace = true,
-- 	release = "1.0.1",
-- 	environment = "dev"
-- })

-- Sentry.captureMessage("hello", Sentry.Level.Info)

-- local function x()
-- 	return debug.traceback("hello")
-- end

-- local function y()
-- 	return x()
-- end

-- Sentry.captureException("test adding synthetic stacktrace")

-- -- Sentry.captureException(y())

-- local ScriptContext = game:GetService("ScriptContext")

-- ScriptContext.Error:Connect(function(message, trace)
-- 	local full = ("%s\nStack Begin\n%sStack End"):format(message, trace)
-- 	-- Sentry.captureException(full)
-- 	print(full)
-- end)

-- pcall(function()
-- 	wait()
-- 	-- x()
-- 	-- error("error from yielding pcall")
-- end)</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="42">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="Workspace" referent="43">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
    </Properties>
    <Item class="Part" referent="44">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Locked">true</bool>
        <Vector3 name="size">
          <X>512</X>
          <Y>20</Y>
          <Z>512</Z>
        </Vector3>
        <Color3uint8 name="Color3uint8">6446690</Color3uint8>
        <Vector3 name="Position">
          <X>0</X>
          <Y>-10</Y>
          <Z>0</Z>
        </Vector3>
        <bool name="Anchored">true</bool>
      </Properties>
    </Item>
  </Item>
</roblox>